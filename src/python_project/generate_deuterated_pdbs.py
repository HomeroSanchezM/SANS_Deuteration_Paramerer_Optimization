#!/usr/bin/env python3
"""
Deuterated PDB Generator with Genetic Algorithm
================================================

Main script to generate a population of deuteration patterns,
create corresponding deuterated PDBs, run SANS simulation,
and evaluate fitness automatically.

Directory structure created:
    <output_dir>/
        ├── gen00_*.pdb            # Deuterated PDB files per generation
        ├── generation_*_summary.txt
        └── ref/                  # Reference PDBs (fully deuterated / protonated)

SANS data is generated by a batch script and stored in:
    <prefix>_primus_out/

Usage examples:
  # Minimal (1 generation, population=6, no config)
  python generate_deuterated_pdbs.py input.pdb

  # Full CLI control
  python generate_deuterated_pdbs.py input.pdb -p 60 -e 5 -g 20 \\
      --d2o-var 10 -m 0.2 -c 0.9 --seed 123 --output_dir results \\
      --q-max 0.35 --i0-threshold 0.15

  # With config file (CLI overrides INI)
  python generate_deuterated_pdbs.py input.pdb --config ga_config.ini -g 50

  # Specify reference file names inside ref/
  python generate_deuterated_pdbs.py input.pdb \\
      --deut-ref D2O_100pc.dat --prot-ref H2O_0pc.dat
"""

import sys
import argparse
import random
import logging
import subprocess
import configparser
from pathlib import Path
from typing import List, Tuple, Dict, Any, Optional

import numpy as np

from __init__ import (
    AMINO_ACIDS,
    Chromosome,
    PopulationGenerator,
    #AA_INDEX,
    restrictions as default_restrictions
)
from pdb_deuteration import PdbDeuteration
from fitness_evaluation import evaluate_population_fitness

# ============================================================================
#                           LOGGING CONFIGURATION
# ============================================================================

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)


# ============================================================================
#                           ARGUMENT PARSING
# ============================================================================

def parse_arguments():
    """
    Parse command-line arguments for the genetic algorithm workflow.
    """
    parser = argparse.ArgumentParser(
        description="Generate deuterated PDBs using a genetic algorithm and evaluate fitness via SANS",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    # ==================== POSITIONAL ====================
    parser.add_argument(
        'pdb_file',
        type=str,
        help='Source PDB file to deuterate'
    )

    # ==================== CONFIG FILE ====================
    parser.add_argument(
        '--config',
        type=str,
        metavar='FILE',
        help='Configuration INI file (CLI arguments override INI)'
    )

    # ==================== I/O PARAMETERS ====================
    io_group = parser.add_argument_group('Input/Output')
    io_group.add_argument(
        '--output_dir',
        type=str,
        help='Output directory (default: <pdb_basename>_deuterated_pdbs)'
    )
    io_group.add_argument(
        '--batch_script',
        type=str,
        default='./process_pdb.sh',
        help='Path to the batch processing script (default: ./process_pdb.sh)'
    )

    # ==================== POPULATION PARAMETERS ====================
    pop_group = parser.add_argument_group('Population parameters')
    pop_group.add_argument(
        '-p', '--population_size',
        type=int,
        help='Population size (MUST be a multiple of 3). Default: 6'
    )
    pop_group.add_argument(
        '-e', '--elitism',
        type=int,
        help='Number of elite individuals preserved (≤ population_size/3). Default: 2'
    )
    pop_group.add_argument(
        '--d2o-var', '--d2o_variation_rate',
        dest='d2o_variation_rate',
        type=int,
        help='Maximum D2O variation amplitude (0–100). Default: 5'
    )

    # ==================== GENETIC PARAMETERS ====================
    gen_group = parser.add_argument_group('Genetic parameters')
    gen_group.add_argument(
        '-m', '--mutation_rate',
        type=float,
        help='Mutation rate (0.0–1.0). Default: 0.15'
    )
    gen_group.add_argument(
        '-c', '--crossover_rate',
        type=float,
        help='Crossover rate (0.0–1.0). Default: 0.8'
    )

    # ==================== EXECUTION PARAMETERS ====================
    exec_group = parser.add_argument_group('Execution parameters')
    exec_group.add_argument(
        '-g', '--generations',
        type=int,
        help='Number of generations to run. Default: 1'
    )
    exec_group.add_argument(
        '--seed',
        type=int,
        help='Random seed for reproducibility. Default: 1 (set to None for random)'
    )

    # ==================== FITNESS EVALUATION PARAMETERS ====================
    fitness_group = parser.add_argument_group('Fitness evaluation parameters')
    fitness_group.add_argument(
        '--q-max',
        type=float,
        help='Maximum q value for truncation (Å⁻¹). Default: 0.3'
    )
    fitness_group.add_argument(
        '--i0-threshold',
        type=float,
        help='Minimum I(0) as fraction of protonated I(0). Default: 0.2'
    )
    fitness_group.add_argument(
        '--deut-ref',
        type=str,
        help='Exact filename of deuterated reference inside ref/ (auto-detected if not given)'
    )
    fitness_group.add_argument(
        '--prot-ref',
        type=str,
        help='Exact filename of protonated reference inside ref/ (auto-detected if not given)'
    )

    # ==================== VERBOSITY ====================
    parser.add_argument(
        '--verbose',
        action='store_true',
        help='Enable debug logging'
    )

    args = parser.parse_args()

    # Set logging level
    if args.verbose:
        logger.setLevel(logging.DEBUG)

    return args


# ============================================================================
#                     CONFIGURATION LOADING & MERGING
# ============================================================================

def load_config_ini(path: str) -> Dict[str, Any]:
    """
    Load genetic algorithm configuration from an INI file.

    Expected sections:
        [POPULATION]
        population_size = int
        elitism = int
        d2o_variation_rate = int

        [GENETIC]
        mutation_rate = float
        crossover_rate = float

        [EXECUTION]
        generations = int
        seed = int (optional)

        [RESTRICTIONS]
        ALA = true/false
        ...

        [FITNESS]   (optional)
        q_max = float
        i0_threshold = float
        deut_ref = str
        prot_ref = str
    """
    if not Path(path).exists():
        raise FileNotFoundError(f"Config file not found: {path}")

    config = configparser.ConfigParser()
    config.read(path)
    cfg = {}

    # ----- POPULATION -----
    if config.has_section("POPULATION"):
        cfg["population_size"] = config.getint("POPULATION", "population_size", fallback=None)
        cfg["elitism"] = config.getint("POPULATION", "elitism", fallback=None)
        cfg["d2o_variation_rate"] = config.getint("POPULATION", "d2o_variation_rate", fallback=None)

    # ----- GENETIC -----
    if config.has_section("GENETIC"):
        cfg["mutation_rate"] = config.getfloat("GENETIC", "mutation_rate", fallback=None)
        cfg["crossover_rate"] = config.getfloat("GENETIC", "crossover_rate", fallback=None)

    # ----- EXECUTION -----
    if config.has_section("EXECUTION"):
        cfg["generations"] = config.getint("EXECUTION", "generations", fallback=None)
        # seed can be empty -> None
        seed_val = config.get("EXECUTION", "seed", fallback=None)
        cfg["seed"] = int(seed_val) if seed_val and seed_val.strip() != "" else None

    # ----- RESTRICTIONS -----
    if config.has_section("RESTRICTIONS"):
        restrictions = []
        for aa in AMINO_ACIDS:
            # default to True if not specified (backward compatibility)
            val = config.getboolean("RESTRICTIONS", aa.code_3, fallback=True)
            restrictions.append(val)
        cfg["restrictions"] = restrictions

    # ----- FITNESS -----
    if config.has_section("FITNESS"):
        cfg["q_max"] = config.getfloat("FITNESS", "q_max", fallback=None)
        cfg["i0_threshold"] = config.getfloat("FITNESS", "i0_threshold", fallback=None)
        cfg["deut_ref"] = config.get("FITNESS", "deut_ref", fallback=None)
        cfg["prot_ref"] = config.get("FITNESS", "prot_ref", fallback=None)

    return cfg


def merge_config(cli_args: argparse.Namespace, ini_cfg: Optional[Dict] = None) -> Dict[str, Any]:
    """
    Merge CLI arguments with INI configuration (CLI takes precedence).
    """
    ini_cfg = ini_cfg or {}

    def pick(cli_val, ini_val, default):
        return cli_val if cli_val is not None else (ini_val if ini_val is not None else default)

    # Default values
    defaults = {
        "population_size": 6,
        "elitism": 2,
        "d2o_variation_rate": 5,
        "mutation_rate": 0.15,
        "crossover_rate": 0.8,
        "generations": 1,
        "seed": 1,
        "q_max": 0.3,
        "i0_threshold": 0.2,
        "deut_ref": None,
        "prot_ref": None,
        "restrictions": [True] * len(AMINO_ACIDS),  # default: all modifiable
        "output_dir": None,
        "batch_script": "./process_pdb.sh",
        "verbose": False,
        "config": None,
    }

    merged = {
        # I/O
        "output_dir": pick(cli_args.output_dir, ini_cfg.get("output_dir"), defaults["output_dir"]),
        "batch_script": pick(cli_args.batch_script, ini_cfg.get("batch_script"), defaults["batch_script"]),

        # Population
        "population_size": pick(cli_args.population_size, ini_cfg.get("population_size"), defaults["population_size"]),
        "elitism": pick(cli_args.elitism, ini_cfg.get("elitism"), defaults["elitism"]),
        "d2o_variation_rate": pick(cli_args.d2o_variation_rate, ini_cfg.get("d2o_variation_rate"), defaults["d2o_variation_rate"]),

        # Genetic
        "mutation_rate": pick(cli_args.mutation_rate, ini_cfg.get("mutation_rate"), defaults["mutation_rate"]),
        "crossover_rate": pick(cli_args.crossover_rate, ini_cfg.get("crossover_rate"), defaults["crossover_rate"]),

        # Execution
        "generations": pick(cli_args.generations, ini_cfg.get("generations"), defaults["generations"]),
        "seed": pick(cli_args.seed, ini_cfg.get("seed"), defaults["seed"]),

        # Fitness
        "q_max": pick(cli_args.q_max, ini_cfg.get("q_max"), defaults["q_max"]),
        "i0_threshold": pick(cli_args.i0_threshold, ini_cfg.get("i0_threshold"), defaults["i0_threshold"]),
        "deut_ref": pick(cli_args.deut_ref, ini_cfg.get("deut_ref"), defaults["deut_ref"]),
        "prot_ref": pick(cli_args.prot_ref, ini_cfg.get("prot_ref"), defaults["prot_ref"]),

        # Restrictions
        "restrictions": ini_cfg.get("restrictions", defaults["restrictions"]),

        # Metadata
        "config_file": cli_args.config,
        "verbose": cli_args.verbose,
        "pdb_file": cli_args.pdb_file,
    }

    return merged


def validate_config(cfg: Dict[str, Any]) -> None:
    """
    Validate all configuration parameters.
    Raises ValueError if any parameter is invalid.
    """
    # Population
    if cfg["population_size"] <= 0:
        raise ValueError("population_size must be > 0")
    if cfg["population_size"] % 3 != 0:
        raise ValueError(f"population_size must be a multiple of 3 (got {cfg['population_size']})")
    if cfg["elitism"] < 0:
        raise ValueError("elitism must be >= 0")
    if cfg["elitism"] > cfg["population_size"] // 3:
        raise ValueError(f"elitism must be ≤ population_size/3 (max {cfg['population_size'] // 3})")

    # Rates
    if not (0.0 <= cfg["mutation_rate"] <= 1.0):
        raise ValueError("mutation_rate must be in [0.0, 1.0]")
    if not (0.0 <= cfg["crossover_rate"] <= 1.0):
        raise ValueError("crossover_rate must be in [0.0, 1.0]")
    if not (0 <= cfg["d2o_variation_rate"] <= 100):
        raise ValueError("d2o_variation_rate must be in [0, 100]")

    # Execution
    if cfg["generations"] < 1:
        raise ValueError("generations must be >= 1")

    # Restrictions
    if len(cfg["restrictions"]) != len(AMINO_ACIDS):
        raise ValueError(
            f"restrictions length ({len(cfg['restrictions'])}) != "
            f"number of amino acids ({len(AMINO_ACIDS)})"
        )

    # Fitness
    if cfg["q_max"] <= 0:
        raise ValueError("q_max must be positive")
    if not (0.0 <= cfg["i0_threshold"] <= 1.0):
        raise ValueError("i0_threshold must be in [0.0, 1.0]")

    # Files (existence checked later)
    if cfg["seed"] is not None and cfg["seed"] < 0:
        raise ValueError("seed must be non-negative")


# ============================================================================
#                     CORE WORKFLOW FUNCTIONS
# ============================================================================

def create_output_directory(output_dir: Optional[str], pdb_file: str) -> Tuple[Path, Path]:
    """Create output directory and ref subdirectory."""
    if output_dir is None:
        output_path = Path(pdb_file).stem + "_deuterated_pdbs"
        output_path = Path(output_path)
    else:
        output_path = Path(output_dir)

    output_path.mkdir(exist_ok=True, parents=True)
    ref_path = output_path / "ref"
    ref_path.mkdir(exist_ok=True)
    logger.info(f"Output directory: {output_path.absolute()}")
    return output_path, ref_path


def generate_pdb_filename(chromosome: Chromosome, index: int, generation: int = 0) -> str:
    """Generate a descriptive PDB filename."""
    num_deut = sum(chromosome.deuteration)
    return f"gen{generation:02d}_chr{index:03d}_d2o{chromosome.d2o:02d}_deutAA{num_deut:02d}.pdb"


def save_population_summary(population: List[Chromosome],
                            output_dir: Path,
                            generation: int = 0) -> None:
    """Save a detailed summary of the population to a text file."""
    summary_file = output_dir / f"generation_{generation:02d}_summary.txt"
    with open(summary_file, 'w', encoding='utf-8') as f:
        f.write("=" * 80 + "\n")
        f.write(f"POPULATION SUMMARY - GENERATION {generation}\n")
        f.write("=" * 80 + "\n\n")
        f.write(f"Population size: {len(population)}\n")

        fitness_values = [c.fitness for c in population if c.fitness is not None]
        if fitness_values:
            f.write(f"Average fitness: {np.mean(fitness_values):.6f}\n")
            f.write(f"Best fitness   : {np.max(fitness_values):.6f}\n")
            f.write(f"Worst fitness  : {np.min(fitness_values):.6f}\n")

        f.write("\n" + "-" * 80 + "\n")
        f.write(f"{'#':<5} {'PDB Filename':<45} {'D2O%':<8} {'AA deut.':<12} {'Fitness':<10}\n")
        f.write("-" * 80 + "\n")
        for i, chrom in enumerate(population, 1):
            filename = generate_pdb_filename(chrom, i, generation)
            num_deut = sum(chrom.deuteration)
            fit_str = f"{chrom.fitness:.6f}" if chrom.fitness is not None else "N/A"
            f.write(f"{i:<5} {filename:<45} {chrom.d2o:<8} {num_deut:<12} {fit_str:<10}\n")
        f.write("-" * 80 + "\n\n")
        f.write("=" * 80 + "\n")
    logger.info(f"Summary saved: {summary_file}")


def run_batch_processing(output_dir: Path, batch_script: str) -> str:
    """Execute the external batch script for SANS simulation."""
    logger.info("=" * 80)
    logger.info(">>> Running batch processing (Pepsi-SANS simulation)...")
    logger.info("=" * 80)
    try:
        result = subprocess.run(
            [batch_script, str(output_dir)],
            check=True,
            capture_output=True,
            text=True
        )
        logger.debug(result.stdout)
        # Infer primus output directory (same logic as the batch script)
        folder_name = output_dir.name
        prefix = folder_name.replace("_deuterated_pdbs", "")
        primus_dir = output_dir.parent / f"{prefix}_primus_out"
        logger.info(f"SANS data generated in: {primus_dir}")
        return str(primus_dir)
    except subprocess.CalledProcessError as e:
        logger.error(f"Batch processing failed (code {e.returncode})")
        logger.error(e.stderr)
        raise RuntimeError(f"Batch script error: {e}")
    except FileNotFoundError:
        raise RuntimeError(f"Batch script not found: {batch_script}")


def evaluate_fitness(primus_output_dir: str,
                     population: List[Chromosome],
                     q_max: float,
                     i0_threshold: float,
                     deut_ref: Optional[str] = None,
                     prot_ref: Optional[str] = None) -> None:
    """
    Evaluate fitness of all chromosomes using SANS data.
    """
    logger.info("=" * 80)
    logger.info(">>> Evaluating population fitness from SANS data...")
    logger.info("=" * 80)
    try:
        fitness_scores, dat_files = evaluate_population_fitness(
            directory=primus_output_dir,
            deut_ref=deut_ref,
            prot_ref=prot_ref,
            q_max=q_max,
            i0_threshold=i0_threshold
        )
        # Assign scores to chromosomes
        min_len = min(len(fitness_scores), len(population))
        for i in range(min_len):
            population[i].fitness = float(fitness_scores[i])

        logger.info(f"Fitness evaluation complete. "
                    f"Passed I0 threshold: {np.sum(fitness_scores > 0)}/{len(fitness_scores)}")
    except Exception as e:
        logger.error(f"Fitness evaluation failed: {e}")
        raise RuntimeError(f"Fitness evaluation error: {e}")


def cleanup_pdb_files(output_dir: Path, generation: int) -> None:
    """Remove PDB files from a specific generation to save disk space."""
    pattern = f"gen{generation:02d}_*.pdb"
    removed = 0
    for pdb in output_dir.glob(pattern):
        try:
            pdb.unlink()
            removed += 1
        except Exception as e:
            logger.warning(f"Could not remove {pdb}: {e}")
    logger.info(f"Cleaned up {removed} PDB files from generation {generation}")


def generate_deuterated_pdbs(pdb_file: str,
                             population: List[Chromosome],
                             output_dir: Path,
                             generation: int = 0) -> None:
    """Generate deuterated PDB files for all chromosomes in the population."""
    logger.info(f"Generating {len(population)} deuterated PDB files (gen {generation})...")
    for i, chrom in enumerate(population, 1):
        try:
            deuterator = PdbDeuteration(pdb_file)
            deuterator.apply_deuteration(chrom.deuteration, chrom.d2o)
            filename = generate_pdb_filename(chrom, i, generation)
            out_path = output_dir / filename
            deuterator.save(str(out_path))
            logger.debug(f"  [{i:03d}] {filename}")
        except Exception as e:
            logger.error(f"  [{i:03d}] FAILED: {e}")
    logger.info(f"Generation {generation} PDBs created.")


def create_reference_pdbs(pdb_file: str,
                          ref_dir: Path,
                          restrictions: List[bool]) -> None:
    """Create fully deuterated and fully protonated reference PDBs."""
    logger.info(">>> Creating reference PDBs (fully deuterated / protonated)")

    # Fully deuterated
    deut_chrom = Chromosome(AMINO_ACIDS, restrictions)
    deut_chrom.deuteration = [True] * len(AMINO_ACIDS)
    deut_chrom.d2o = 100
    deut_pdb = PdbDeuteration(pdb_file)
    deut_pdb.apply_deuteration(deut_chrom.deuteration, deut_chrom.d2o)
    # Fix: use f-string with Path / operator
    deut_filename = f"{Path(pdb_file).stem}_total_deuteration.pdb"
    deut_path = ref_dir / deut_filename
    deut_pdb.save(str(deut_path))
    logger.info(f"  Deuterated reference: {deut_path.name}")

    # Fully protonated
    prot_chrom = Chromosome(AMINO_ACIDS, restrictions)
    prot_chrom.deuteration = [False] * len(AMINO_ACIDS)
    prot_chrom.d2o = 0
    prot_pdb = PdbDeuteration(pdb_file)
    prot_pdb.apply_deuteration(prot_chrom.deuteration, prot_chrom.d2o)
    prot_filename = f"{Path(pdb_file).stem}_total_protonation.pdb"
    prot_path = ref_dir / prot_filename
    prot_pdb.save(str(prot_path))
    logger.info(f"  Protonated reference: {prot_path.name}")


def display_population_summary(population: List[Chromosome], generation: int) -> None:
    """Print top chromosomes and basic statistics."""
    sorted_pop = sorted(population, key=lambda x: x.fitness if x.fitness else 0, reverse=True)
    logger.info(f"\n>>> Generation {generation} - Top 3 chromosomes:")
    for i in range(min(3, len(sorted_pop))):
        c = sorted_pop[i]
        fit_str = f"{c.fitness:.4f}" if c.fitness else "N/A"
        logger.info(f"  {i + 1}. D2O={c.d2o:2d}%, AA deut={sum(c.deuteration):2d}/20, Fitness={fit_str}")


# ============================================================================
#                           MAIN EXECUTION
# ============================================================================

def main():
    cli_args = parse_arguments()

    # Load config file if provided
    ini_cfg = None
    if cli_args.config:
        try:
            ini_cfg = load_config_ini(cli_args.config)
            logger.info(f"Loaded configuration from: {cli_args.config}")
        except (FileNotFoundError, ValueError) as e:
            logger.error(f"Config error: {e}")
            sys.exit(1)

    # Merge CLI and INI
    try:
        cfg = merge_config(cli_args, ini_cfg)
        validate_config(cfg)
    except ValueError as e:
        logger.error(f"Configuration validation failed: {e}")
        sys.exit(1)

    # Set random seed
    if cfg["seed"] is not None:
        random.seed(cfg["seed"])
        np.random.seed(cfg["seed"])
        logger.info(f"Random seed set to: {cfg['seed']}")

    # Display configuration
    logger.info("=" * 80)
    logger.info("DEUTERATED PDB GENERATION WITH GENETIC ALGORITHM")
    logger.info("=" * 80)
    logger.info(f"Source PDB           : {cfg['pdb_file']}")
    logger.info(f"Population size      : {cfg['population_size']}")
    logger.info(f"Elitism              : {cfg['elitism']}")
    logger.info(f"D2O variation rate   : ±{cfg['d2o_variation_rate']}%")
    logger.info(f"Mutation rate        : {cfg['mutation_rate']}")
    logger.info(f"Crossover rate       : {cfg['crossover_rate']}")
    logger.info(f"Generations          : {cfg['generations']}")
    logger.info(f"Q max (fitness)      : {cfg['q_max']} Å⁻¹")
    logger.info(f"I0 threshold         : {cfg['i0_threshold']}")
    logger.info(f"Batch script         : {cfg['batch_script']}")
    logger.info(f"Output directory     : {cfg['output_dir'] or '(auto)'}")
    if cfg['config_file']:
        logger.info(f"Config file          : {cfg['config_file']}")
    logger.info("=" * 80)

    # Check PDB file existence
    pdb_path = Path(cfg['pdb_file'])
    if not pdb_path.exists():
        logger.error(f"PDB file not found: {pdb_path}")
        sys.exit(1)

    # Check batch script
    if not Path(cfg['batch_script']).exists():
        logger.error(f"Batch script not found: {cfg['batch_script']}")
        sys.exit(1)

    # Create output directories
    output_dir, ref_dir = create_output_directory(cfg['output_dir'], str(pdb_path))

    # Create reference PDBs using the loaded restrictions
    create_reference_pdbs(str(pdb_path), ref_dir, cfg['restrictions'])

    # Initialize population generator
    generator = PopulationGenerator(
        aa_list=AMINO_ACIDS,
        modifiable=cfg['restrictions'],
        population_size=cfg['population_size'],
        elitism=cfg['elitism'],
        d2o_variation_rate=cfg['d2o_variation_rate']
    )

    # ========== GENERATION 0 ==========
    logger.info("\n>>> GENERATION 0 - Creating initial population")
    population = generator.generate_initial_population()
    logger.info(f"Initial population: {len(population)} unique chromosomes")

    # Generate PDBs
    generate_deuterated_pdbs(str(pdb_path), population, output_dir, generation=0)

    # Run SANS simulation
    primus_dir = run_batch_processing(output_dir, cfg['batch_script'])

    # Evaluate fitness
    evaluate_fitness(
        primus_dir,
        population,
        q_max=cfg['q_max'],
        i0_threshold=cfg['i0_threshold'],
        deut_ref=cfg['deut_ref'],
        prot_ref=cfg['prot_ref']
    )

    # Sort and summarize
    sorted_pop = sorted(population, key=lambda x: x.fitness if x.fitness else 0, reverse=True)
    display_population_summary(sorted_pop, generation=0)
    save_population_summary(sorted_pop, output_dir, generation=0)

    # ========== SUBSEQUENT GENERATIONS ==========
    for gen in range(1, cfg['generations']):
        logger.info("\n" + "=" * 80)
        logger.info(f">>> GENERATION {gen} - Population evolution")
        logger.info("=" * 80)

        # Cleanup previous generation's PDBs
        cleanup_pdb_files(output_dir, generation=gen - 1)

        # Generate next generation
        population = generator.generate_next_generation(
            previous_population=sorted_pop,
            mutation_rate=cfg['mutation_rate'],
            crossover_rate=cfg['crossover_rate'],
            d2o_variation_rate=cfg['d2o_variation_rate']
        )
        logger.info(f"New population: {len(population)} chromosomes")

        # Generate PDBs
        generate_deuterated_pdbs(str(pdb_path), population, output_dir, generation=gen)

        # Run SANS
        primus_dir = run_batch_processing(output_dir, cfg['batch_script'])

        # Evaluate fitness
        evaluate_fitness(
            primus_dir,
            population,
            q_max=cfg['q_max'],
            i0_threshold=cfg['i0_threshold'],
            deut_ref=cfg['deut_ref'],
            prot_ref=cfg['prot_ref']
        )

        # Sort and summarize
        sorted_pop = sorted(population, key=lambda x: x.fitness if x.fitness else 0, reverse=True)
        display_population_summary(sorted_pop, generation=gen)
        save_population_summary(sorted_pop, output_dir, generation=gen)

    # ========== FINAL SUMMARY ==========
    logger.info("\n" + "=" * 80)
    logger.info("GENETIC ALGORITHM COMPLETED SUCCESSFULLY!")
    logger.info("=" * 80)
    logger.info(f"Total generations    : {cfg['generations']}")
    logger.info(f"Total PDBs generated : {cfg['generations'] * cfg['population_size']}")
    logger.info(f"Results in           : {output_dir.absolute()}")
    logger.info(f"SANS data in         : {primus_dir}")

    if sorted_pop:
        best = sorted_pop[0]
        logger.info(f"\n>>> Best solution found:")
        logger.info(f"  D2O: {best.d2o}%")
        logger.info(f"  Deuterated amino acids: {sum(best.deuteration)}/20")
        logger.info(f"  Fitness: {best.fitness:.6f}")
        logger.info(f"  PDB: {generate_pdb_filename(best, 1, cfg['generations'] - 1)}")

    logger.info("=" * 80)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.warning("\nInterrupted by user")
        sys.exit(1)
    except Exception as e:
        logger.exception(f"Fatal error: {e}")
        sys.exit(1)